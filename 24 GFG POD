import java.util.*;

class Solution {

    static class Edge {
        int u, v, w;
        Edge(int u, int v, int w) {
            this.u = u;
            this.v = v;
            this.w = w;
        }
    }

    static class DSU {
        int[] parent, rank;
        DSU(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) parent[i] = i;
        }
        int find(int x) {
            if (parent[x] != x) parent[x] = find(parent[x]);
            return parent[x];
        }
        boolean union(int a, int b) {
            a = find(a);
            b = find(b);
            if (a == b) return false;
            if (rank[a] < rank[b]) parent[a] = b;
            else if (rank[b] < rank[a]) parent[b] = a;
            else { parent[b] = a; rank[a]++; }
            return true;
        }
    }

    public int secondMST(int V, int[][] edges) {

        int E = edges.length;
        Edge[] arr = new Edge[E];
        for (int i = 0; i < E; i++) {
            arr[i] = new Edge(edges[i][0], edges[i][1], edges[i][2]);
        }
        Arrays.sort(arr, (a, b) -> a.w - b.w);

        boolean[] used = new boolean[E];
        DSU dsu = new DSU(V);

        int mstCost = 0, cnt = 0;

        // Build MST using Kruskal
        for (int i = 0; i < E; i++) {
            if (dsu.union(arr[i].u, arr[i].v)) {
                mstCost += arr[i].w;
                used[i] = true;
                cnt++;
            }
        }

        if (cnt != V - 1) return -1;  // No MST exists

        int ans = Integer.MAX_VALUE;

        // Try replacing each MST edge
        for (int rem = 0; rem < E; rem++) {
            if (!used[rem]) continue;

            DSU dsu2 = new DSU(V);
            int cost = 0, edgesUsed = 0;

            for (int i = 0; i < E; i++) {
                if (i == rem) continue;
                if (dsu2.union(arr[i].u, arr[i].v)) {
                    cost += arr[i].w;
                    edgesUsed++;
                }
            }

            if (edgesUsed == V - 1 && cost > mstCost) {
                ans = Math.min(ans, cost);
            }
        }

        return ans == Integer.MAX_VALUE ? -1 : ans;
    }
}
