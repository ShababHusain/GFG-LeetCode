class Solution:
    def longestSubarray(self, arr):
        n = len(arr)
        if n == 0:
            return 0

        # Transform: B[i] = -arr[i]
        B = [-x for x in arr]

        # prev smaller (strict) and next smaller (strict)
        prev_smaller = [-1] * n
        next_smaller = [n] * n

        stack = []
        for i in range(n):
            # strictly smaller for prev (pop >=)
            while stack and B[stack[-1]] >= B[i]:
                stack.pop()
            prev_smaller[i] = stack[-1] if stack else -1
            stack.append(i)

        stack = []
        for i in range(n - 1, -1, -1):
            # strictly smaller for next (pop >)
            while stack and B[stack[-1]] > B[i]:
                stack.pop()
            next_smaller[i] = stack[-1] if stack else n
            stack.append(i)

        # ans_len[k] = maximum of minimums of B over all windows of length k
        # initialize to very small value
        NEG_INF = -10**30
        ans_len = [NEG_INF] * (n + 1)  # use 1..n

        for i in range(n):
            length = next_smaller[i] - prev_smaller[i] - 1
            if B[i] > ans_len[length]:
                ans_len[length] = B[i]

        # fill missing entries: for smaller window sizes the best min can't be less than a larger size's best
        for k in range(n - 1, 0, -1):
            if ans_len[k] < ans_len[k + 1]:
                ans_len[k] = ans_len[k + 1]

        # g(k) = minimum possible maximum for windows of length k = -ans_len[k]
        # find largest k with g(k) <= k
        result = 0
        for k in range(1, n + 1):
            if ans_len[k] == NEG_INF:
                # no window of this exact length (shouldn't happen after filling), skip
                continue
            min_possible_max = -ans_len[k]
            if min_possible_max <= k:
                result = max(result, k)

        return result
