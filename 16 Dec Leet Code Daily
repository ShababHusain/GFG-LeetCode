import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    private List<Integer>[] adj;
    private int[] present;
    private int[] future;
    private int budget;
    private int n;

    // Use a large negative number for "impossible" states to prevent profit overflow issues
    private static final int NEG_INF = -1_000_000_000;

    public int maxProfit(int n, int[] present, int[] future, int[][] hierarchy, int budget) {
        this.n = n;
        this.present = present;
        this.future = future;
        this.budget = budget;

        // 1. Build Adjacency List (Tree)
        adj = new ArrayList[n + 1];
        for (int i = 0; i <= n; i++) {
            adj[i] = new ArrayList<>();
        }
        for (int[] edge : hierarchy) {
            adj[edge[0]].add(edge[1]); // u is boss of v
        }

        // 2. Start DFS from the root (Employee 1)
        // rootRes[0] is the result for the CEO (no parent buyer = no discount)
        int[][] rootRes = dfs(1);

        // 3. Find the maximum profit in the CEO's 'noParentBuy' table
        int maxProfit = 0;
        for (int p : rootRes[0]) {
            maxProfit = Math.max(maxProfit, p);
        }
        return maxProfit;
    }

    /**
     * Performs DFS and returns the DP table for the subtree rooted at u.
     * Returns: int[2][budget + 1]
     * - [0]: DP table if u's parent DID NOT buy (u pays full price if they buy).
     * - [1]: DP table if u's parent DID buy (u pays discounted price if they buy).
     */
    private int[][] dfs(int u) {
        // Aggregates for the children's subtrees based on u's decision
        // aggNoBuy: Max profit if u does NOT buy (children see "parent didn't buy")
        int[] aggNoBuy = new int[budget + 1];
        
        // aggBuy: Max profit if u DOES buy (children see "parent bought")
        int[] aggBuy = new int[budget + 1];

        // Initialize: Cost 0 has profit 0, all other costs are impossible.
        Arrays.fill(aggNoBuy, NEG_INF);
        Arrays.fill(aggBuy, NEG_INF);
        aggNoBuy[0] = 0;
        aggBuy[0] = 0;

        // 1. Group Knapsack Merge for all children
        for (int v : adj[u]) {
            int[][] childRes = dfs(v);
            
            // Merge for the case where u does NOT buy (v uses childRes[0])
            aggNoBuy = merge(aggNoBuy, childRes[0]);
            
            // Merge for the case where u DOES buy (v uses childRes[1])
            aggBuy = merge(aggBuy, childRes[1]);
        }

        // 2. Calculate current node u's potential costs and profits
        int pIdx = u - 1; // 0-based index
        
        int costFull = present[pIdx];
        int profitFull = future[pIdx] - costFull;
        
        int costDisc = present[pIdx] / 2; // floor(price / 2)
        int profitDisc = future[pIdx] - costDisc;

        // 3. Construct the two result tables for u
        int[][] res = new int[2][budget + 1];
        Arrays.fill(res[0], NEG_INF);
        Arrays.fill(res[1], NEG_INF);

        // --- Calculate res[0]: Parent DID NOT buy (u pays full price) ---

        // Option A: u does not buy (Cost 0, Profit 0). Children results come from aggNoBuy.
        System.arraycopy(aggNoBuy, 0, res[0], 0, budget + 1);
        
        // Option B: u buys (Cost costFull, Profit profitFull). Children results come from aggBuy.
        if (costFull <= budget) {
            for (int w = 0; w <= budget - costFull; w++) {
                if (aggBuy[w] != NEG_INF) {
                    int newCost = w + costFull;
                    int newProfit = aggBuy[w] + profitFull;
                    res[0][newCost] = Math.max(res[0][newCost], newProfit);
                }
            }
        }

        // --- Calculate res[1]: Parent DID buy (u pays discounted price) ---

        // Option A: u does not buy (Cost 0, Profit 0). Children results come from aggNoBuy.
        // NOTE: This uses aggNoBuy because u's decision affects its children, not its parent.
        System.arraycopy(aggNoBuy, 0, res[1], 0, budget + 1);

        // Option B: u buys (Cost costDisc, Profit profitDisc). Children results come from aggBuy.
        if (costDisc <= budget) {
            for (int w = 0; w <= budget - costDisc; w++) {
                if (aggBuy[w] != NEG_INF) {
                    int newCost = w + costDisc;
                    int newProfit = aggBuy[w] + profitDisc;
                    res[1][newCost] = Math.max(res[1][newCost], newProfit);
                }
            }
        }

        return res;
    }

    /**
     * Standard knapsack merge operation for two groups (subtrees).
     * newDP[w] = max(dpA[i] + dpB[j]) where i + j = w
     */
    private int[] merge(int[] dpA, int[] dpB) {
        int[] newDP = new int[budget + 1];
        Arrays.fill(newDP, NEG_INF);

        for (int i = 0; i <= budget; i++) {
            if (dpA[i] == NEG_INF) continue;
            
            for (int j = 0; j <= budget - i; j++) {
                if (dpB[j] == NEG_INF) continue;
                
                int combinedCost = i + j;
                int combinedProfit = dpA[i] + dpB[j];
                
                newDP[combinedCost] = Math.max(newDP[combinedCost], combinedProfit);
            }
        }
        return newDP;
    }
}
