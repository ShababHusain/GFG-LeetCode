import java.util.*;

class Solution {
    public int maxPartitionsAfterOperations(String s, int k) {
        Map<Long, Integer> mem = new HashMap<>();
        // dp(0, true, 0) returns number of additional cuts after the initial implicit partition,
        // so we add 1 for the final partition count.
        return maxPartitionsAfterOperations(s, 0, true, 0, k, mem) + 1;
    }

    // Returns the max number of partitions of s[i..end), where canChange indicates
    // whether we still have the one allowed change, and mask is the bitmask of letters
    // already present in the current partition.
    private int maxPartitionsAfterOperations(final String s, int i, boolean canChange, int mask,
                                             int k, Map<Long, Integer> mem) {
        if (i == s.length()) return 0;

        long key = ((long)i << 27) | ((canChange ? 1L : 0L) << 26) | (mask & ((1<<26) - 1));
        if (mem.containsKey(key)) return mem.get(key);

        // Option 1: use the current character s.charAt(i)
        int curBit = 1 << (s.charAt(i) - 'a');
        int res = getRes(s, i, canChange, mask, curBit, k, mem);

        // Option 2: if allowed, try changing s[i] to any letter 'a'..'z'
        if (canChange) {
            for (int j = 0; j < 26; ++j) {
                int bit = 1 << j;
                // if bit equals curBit, this is same as option1 (but harmless to test)
                res = Math.max(res, getRes(s, i, false, mask, bit, k, mem));
            }
        }

        mem.put(key, res);
        return res;
    }

    // Helper: consider adding a letter with bit `newBit` at position i.
    // If newMask has more than k bits, this forces a fresh start (count +1)
    // and the mask for next recursion is newBit (starting a new partition with that letter).
    private int getRes(final String s, int i, boolean nextCanChange, int mask, int newBit,
                       int k, Map<Long, Integer> mem) {
        int newMask = mask | newBit;
        if (Integer.bitCount(newMask) > k) {
            // start a new partition here, count 1, and proceed with mask = newBit
            return 1 + maxPartitionsAfterOperations(s, i + 1, nextCanChange, newBit, k, mem);
        } else {
            // continue current partition with updated mask
            return maxPartitionsAfterOperations(s, i + 1, nextCanChange, newMask, k, mem);
        }
    }
}
