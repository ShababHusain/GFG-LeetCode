import java.util.*;

class Solution {
    int[] treeMin, treeMax, lazy;

    public int longestBalanced(int[] nums) {
        int n = nums.length;
        // Segment tree to store B(L, R) for all L in [0, R]
        treeMin = new int[4 * n];
        treeMax = new int[4 * n];
        lazy = new int[4 * n];
        
        int[] lastSeen = new int[100001];
        Arrays.fill(lastSeen, -1);
        
        int maxLen = 0;
        for (int r = 0; r < n; r++) {
            int val = nums[r];
            int prevIdx = lastSeen[val];
            int delta = (val % 2 == 0) ? 1 : -1;
            
            // Update balance for all starting positions from prevIdx + 1 to r
            update(1, 0, n - 1, prevIdx + 1, r, delta);
            lastSeen[val] = r;
            
            // Find the leftmost index L in [0, r] where B(L, r) == 0
            int l = findLeftmostZero(1, 0, n - 1, 0, r);
            if (l != -1) {
                maxLen = Math.max(maxLen, r - l + 1);
            }
        }
        return maxLen;
    }

    private void push(int node) {
        if (lazy[node] != 0) {
            lazy[2 * node] += lazy[node];
            treeMin[2 * node] += lazy[node];
            treeMax[2 * node] += lazy[node];
            
            lazy[2 * node + 1] += lazy[node];
            treeMin[2 * node + 1] += lazy[node];
            treeMax[2 * node + 1] += lazy[node];
            
            lazy[node] = 0;
        }
    }

    private void update(int node, int start, int end, int l, int r, int val) {
        if (start > end || start > r || end < l) return;
        if (start >= l && end <= r) {
            lazy[node] += val;
            treeMin[node] += val;
            treeMax[node] += val;
            return;
        }
        push(node);
        int mid = (start + end) / 2;
        update(2 * node, start, mid, l, r, val);
        update(2 * node + 1, mid + 1, end, l, r, val);
        treeMin[node] = Math.min(treeMin[2 * node], treeMin[2 * node + 1]);
        treeMax[node] = Math.max(treeMax[2 * node], treeMax[2 * node + 1]);
    }

    private int findLeftmostZero(int node, int start, int end, int l, int r) {
        // Pruning: if 0 is not within [min, max] of this range, it can't be here
        if (start > end || start > r || end < l || treeMin[node] > 0 || treeMax[node] < 0) {
            return -1;
        }
        if (start == end) {
            return treeMin[node] == 0 ? start : -1;
        }
        push(node);
        int mid = (start + end) / 2;
        // Prioritize the left child to find the "leftmost" zero
        int res = findLeftmostZero(2 * node, start, mid, l, r);
        if (res == -1) {
            res = findLeftmostZero(2 * node + 1, mid + 1, end, l, r);
        }
        return res;
    }
}
