import java.util.*;

class Solution {
    public static int mergeStones(int[] stones, int k) {
        int n = stones.length;
        if (n == 0) return 0;
        // Feasibility
        if ((n - 1) % (k - 1) != 0) return -1;

        // prefix sums
        int[] pre = new int[n + 1];
        for (int i = 0; i < n; ++i) pre[i + 1] = pre[i] + stones[i];

        final int INF = Integer.MAX_VALUE / 4;
        // dp[i][j][t] : min cost to merge stones[i..j] into t piles, 1 <= t <= k
        int[][][] dp = new int[n][n][k + 1];
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                Arrays.fill(dp[i][j], INF);

        // base: single pile range
        for (int i = 0; i < n; ++i) dp[i][i][1] = 0;

        // lengths
        for (int len = 2; len <= n; ++len) {
            for (int i = 0; i + len - 1 < n; ++i) {
                int j = i + len - 1;
                // compute dp[i][j][t] for t = 2..k
                for (int t = 2; t <= k; ++t) {
                    // try splitting into x piles on left and t-x on right
                    for (int m = i; m < j; ++m) {
                        for (int x = 1; x < t; ++x) {
                            int left = dp[i][m][x];
                            int right = dp[m + 1][j][t - x];
                            if (left == INF || right == INF) continue;
                            dp[i][j][t] = Math.min(dp[i][j][t], left + right);
                        }
                    }
                }
                // If we can make k piles from [i..j], we can merge them into 1 pile with extra cost = sum(i..j)
                if (dp[i][j][k] < INF) {
                    dp[i][j][1] = dp[i][j][k] + (pre[j + 1] - pre[i]);
                }
            }
        }

        int ans = dp[0][n - 1][1];
        return ans >= INF ? -1 : ans;
    }
}
    
