class Solution {
    public ArrayList<Integer> constructArr(int[] arr) {
        ArrayList<Integer> result = new ArrayList<>();
        int m = arr.length;
        if (m == 0) return result;

        // find n such that n*(n-1)/2 == m
        // n = (1 + sqrt(1 + 8*m)) / 2
        int n = (int) ((1 + Math.sqrt(1 + 8L * m)) / 2);
        if (1L * n * (n - 1) / 2 != m) {
            // invalid size
            return result;
        }

        if (n == 1) {
            // no pair sums possible; ambiguous, but return single 0
            result.add(0);
            return result;
        }

        if (n == 2) {
            // single sum s = arr[0]; return any pair (a,b) with a+b = s
            // choose a = s-1, b = 1 when possible to keep positive values
            int s = arr[0];
            if (s > 1) {
                result.add(s - 1);
                result.add(1);
            } else {
                // s == 1 -> choose (1,0)
                result.add(1);
                result.add(0);
            }
            return result;
        }

        // n >= 3
        // s01 = arr[0], s02 = arr[1], s12 = arr[n-1]
        long s01 = arr[0];
        long s02 = arr[1];
        long s12 = arr[n - 1];

        long numerator = s01 + s02 - s12;
        if (numerator % 2 != 0) {
            // res0 must be integer; invalid input
            return result;
        }
        long res0 = numerator / 2;

        long[] res = new long[n];
        res[0] = res0;
        // s0i are at indices 0..n-2 in arr
        for (int i = 1; i < n; ++i) {
            long s0i = arr[i - 1];
            res[i] = s0i - res0;
        }

        // Rebuild pair-sum array in the same ordered format and compare on the fly
        int idx = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                long expected = res[i] + res[j];
                if (expected != arr[idx]) {
                    // mismatch -> invalid reconstruction
                    return new ArrayList<>();
                }
                idx++;
            }
        }

        // If we reach here, reconstruction is valid; convert to ArrayList<Integer>
        for (int i = 0; i < n; ++i) {
            result.add((int) res[i]);
        }
        return result;
    }
}
